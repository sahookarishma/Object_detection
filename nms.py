# -*- coding: utf-8 -*-
"""NMS

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FfVuERmiMfVFvX2AHirMwXn5pyP5pWRn

##Intersection over union'
"""

import torch
def intersection_over_union(boxes_preds, boxes_labels, box_format):
  ### boxes_preds shape is (N, 4) where n is the number of box

  if box_format == "midpoint":
    box1_x1 = boxes_preds[...,0:1] - boxes_preds[...,2:3] / 2
    box1_y1 = boxes_preds[...,1:2] - boxes_preds[...,3:4] / 2
    box1_x2 = boxes_preds[...,0:1] + boxes_preds[...,2:3] / 2
    box1_y2 = boxes_preds[...,1:2] + boxes_preds[...,3:4] / 2
    box2_x1 = boxes_labels[...,0:1] - boxes_labels[...,2:3] / 2
    box2_y1 = boxes_labels[...,1:2] - boxes_labels[...,3:4] / 2
    box2_x2 = boxes_labels[...,0:1] + boxes_labels[...,2:3] / 2
    box2_y2 = boxes_labels[...,1:2] + boxes_labels[...,3:4] / 2

  elif box_format == "corners":
    box1_x1 = boxes_preds[...,0:1]
    box1_y1 = boxes_preds[...,1:2]
    box1_x2 = boxes_preds[...,2:3]
    box1_y2 = boxes_preds[...,3:4]
    box2_x1 = boxes_labels[...,0:1]
    box2_y1 = boxes_labels[...,1:2]
    box2_x2 = boxes_labels[...,2:3]
    box2_y2 = boxes_labels[...,3:4]


  x1 = torch.max(box1_x1, box2_x1)
  y1 = torch.max(box1_y1, box2_y1)
  x2 = torch.min(box1_x2, box2_x2)
  y2 = torch.min(box1_y2, box2_y2)

  ## .clamp(0) is for the case when the bounding boxes do not intersect. then one of the value should be zero to make the whole IoU = zero
  intersection = (x2 - x1).clamp(0) * (y2 - y1).clamp(0)


  box1_area = abs((box1_x2 - box1_x1) * (box1_y2 - box1_y1))
  box2_area = abs((box2_x2 - box2_x1) * (box2_y2 - box2_y1))
  Iou = intersection / (box1_area + box2_area - intersection + 1e-6)

  return Iou.squeeze()

# Define two boxes: [x1, y1, x2, y2]
boxes_preds = torch.tensor([10, 10, 50, 50], dtype=torch.float32)
boxes_labels = torch.tensor([30, 30, 70, 70], dtype=torch.float32)

iou = intersection_over_union(boxes_preds, boxes_labels, box_format='corners')
print(iou)

boxes_preds = torch.tensor([
    [10, 10, 50, 50],
    [30, 30, 60, 60]
], dtype=torch.float32)

boxes_labels = torch.tensor([
    [20, 20, 40, 40],
    [35, 35, 55, 55]
], dtype=torch.float32)

ious = intersection_over_union(boxes_preds, boxes_labels, box_format="corners")
print("IoUs for all box pairs:", ious)

preds = torch.tensor([[40, 55, 40, 50]], dtype=torch.float32)  # x_center, y_center, w, h
labels = torch.tensor([[65, 75, 50, 50]], dtype=torch.float32)

print(intersection_over_union(preds, labels, box_format="midpoint"))

"""##Non max suppression

"""

import torch
def non_max_suppression(bboxes, iou_thresholds, threshold, box_format ="corners"):
  assert type(bboxes) == list
  bboxes = [box for box in bboxes if box[1]> threshold]
  bboxes = sorted(bboxes, key=lambda x: x[1], reverse=True)
  nms_boxes = []

  while bboxes:
    chosen_box = bboxes.pop(0)
    nms_boxes.append(chosen_box)

    bboxes = [
        box
        for box in bboxes
        if box[0] != chosen_box[0]
        or intersection_over_union(
            torch.tensor(chosen_box[2:]),
            torch.tensor(box[2:]),
            box_format=box_format
        ) < iou_thresholds
    ]

    return nms_boxes

boxes = [
    [0, 0.9, 10, 10, 50, 50],  # class, confidence, x1, y1, x2, y2
    [0, 0.8, 12, 12, 48, 48],
    [0, 0.7, 100, 100, 150, 150],
    [1, 0.95, 10, 10, 50, 50]  # different class â†’ not suppressed
]

result = non_max_suppression(boxes, iou_thresholds=0.5, threshold=0.6)
for box in result:
    print(f"Kept Box: {box}")

